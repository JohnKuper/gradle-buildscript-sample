
/**
 * Uses the build lifecycle callback 'afterEvaluate' and creates custom convenient tasks which can be executed, for instance, on Jenkins.
 * Each task is configured and depends on all necessary tasks from the whole project (all unit tests, assembles and zip task).
 */
afterEvaluate {
    createDistTask(android.buildTypes.release, "distributionRelease", "production", ["production"])
    createDistTask(android.buildTypes.debug, "distributionDebug", "all", null)
    createDistTask(android.buildTypes.debug, "distributionBetaDebug", "beta", ["beta"])
}

def createDistTask(buildType, distTaskName, outputVariantName, filter) {
    Task distTask = tasks.create(name: distTaskName, group: 'distribution') << {}
    Task zipTask = createZipDistributionTask(buildType, distTaskName, outputVariantName)
    setupDependentTasks(buildType, distTask, zipTask, filter)
}

Task createZipDistributionTask(buildType, distTaskName, outputVariantName) {
    String zipTaskName = distTaskName + "Zip"
    Task zipTask = tasks.create(name: zipTaskName, type: Zip) {

        includeEmptyDirs false
        from(buildDir.path + '/outputs/apk') {
            exclude '**/*unaligned*'
        }
        from(buildDir.path + '/outputs/mapping') {
            //Since all mapping.txt files generated by Proguard are the same in our case, we only want to add one to the distribution ZIP file
            duplicatesStrategy = DuplicatesStrategy.EXCLUDE
            eachFile { FileCopyDetails fcp ->
                if (!fcp.name.equals("mapping.txt")) {
                    fcp.exclude()
                } else {
                    def segments = fcp.relativePath.segments
                    //Cuts the path to the file in order to put only mapping.txt into ZIP file
                    def pathSegments = segments[2..-1] as String[]
                    fcp.relativePath = new RelativePath(!fcp.file.isDirectory(), pathSegments)
                }
            }
        }

        archiveName 'buildscript-'
        if (!outputVariantName.equalsIgnoreCase('production')) {
            archiveName += outputVariantName + "-" + buildType.name + '-'
        }
        archiveName += android.defaultConfig.versionName + '.zip'
    }
    return zipTask
}

def setupDependentTasks(buildType, distTask, zipTask, filter) {
    tasks.each { task ->
        String taskName = task.name.toLowerCase();
        //Looking for all necessary assemble tasks and apply filter to task name(production, beta or null) for setup dependent tasks
        if (taskName.contains("assemble") && taskName.endsWith(buildType.name)
                && !taskName.equalsIgnoreCase("assemble" + buildType.name) && isTaskNameContainsFilter(taskName, filter)) {
            String unitTestTask = 'test' + task.name.substring("assemble".length()) + 'UnitTest'
            distTask.dependsOn unitTestTask
            distTask.dependsOn task
            distTask.dependsOn zipTask
        }
    }
}

def isTaskNameContainsFilter(taskName, filter) {
    if (filter == null) return true
    return filter.any { taskName.contains(it) }
}
